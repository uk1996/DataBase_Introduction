#### 1. 트랜잭션의 개념

- 하나의 작업을 수행하기 위해 필요한 데이터베이스 연산들을 모아놓은 것으로, 논리적인 작업의 단위

<br/>

#### 2. 트랜잭션 특정

- 원자성: 트랜잭션의 연산이 모두 정상적으로 수행되거나 하나도 수행되지 않아야 한다.
- 일관성: 트랜잭션이 수행된 후에도 데이터베이스가 일관성 있는 상태여야 한다.
- 격리성: 수행 중인 트랜잭션이 완료될 때가지 다른 트랜잭션이들이 중간 연산 결과에 접근할 수 없다.
- 지속성: 트랜잭션의 수행이 완료된 후에 데이테베이스에 반영한 결과는 영구적이어야 한다.

<br/>

#### 3. 트랜잭션의 연산

- commit 연산: 작업 완료
- rollback 연산: 작업 취소

<br/>

#### 4. 트랜잭션의 상태

- 활동 상태: 트랜잭션이 수행을 시작하여 현재 수행 중인 상태
- 부분 완료 상태: 트랜잭션의 마지막 연산이 실행을 끝낸 직후의 상태
- 완료 상태: 트랜잭션이 성공적으로 완료되어 commit 연산을 실행한 상태
- 실패 상태: 장애가 발생하여 트랜잭션의 수행이 중단된 상태
- 철회 상태: 트랜잭션의 수행 실패로 rollback 연산을 실행한 상태

#### 5. 장애의 정의와 유형

시스템이 제대로 동작하지 않는 상태

- 트랜잭션 장애
- 시스템 장애
- 미디어 장애

<br/>

#### 6. 회복의 정의와 연산

장애가 발생했을 때 데이터베이스를 장애가 발생하기 전의 일관된 상태로 복구시키는 것

- redo(재실행) 연산
- undo(취소) 연산

<br/>

#### 7. 회복기법의 유형

- 로그 회복 기법: 로그를 이용한 회복
  - 즉시 갱신 회복 기법
  - 지연 갱신 회복 기법
- 검사 시점 회복 기법: 검사 시점을 이용한 회복
  - 즉시 갱신 회복 기법
  - 지연 갱신 회복 기법
- 미디어 회복 기법: 데이터베이스 덤프(복사본)를 이용한 회복

<br/>

#### 8. 로그 회복 기법

로그를 이용한 회복 기법

- 즉시 갱신 회복: 트랜잭션을 수행하는 도중에 데이터 변경 연산의 결과를 데이터베이스에 즉시 반영할때 사용
- 지연 갱신 회복: 트랜잭션이 부분 완료되면 데이터 변경 연산의 결과를 데이터베이스에 한번에 반영할때 사용

<br/>

#### 9. 병행 수행과 병행 제어

- 병행 수행: 여러 개의 트랜잭션을 동시에 수행하는 것으로, 갱신 분실, 모순성, 연쇄 복귀의 문제가 있다.
- 병행 제어: 병행 수행 시 문제가 발생하지 않고 정확한 결과를 얻을 수 있도록 트랜잭션의 수행을 제어하는 것

<br/>

#### 10. 트랜잭션 스케줄

트랜잭션에 포함된 연산들을 실행하는 순서

- 직렬 스케줄: 인터리빙 방식을 이용하지 않고 트랜잭션별로 연산들을 순차적으로 실행시키는 것
- 비직렬 스케줄: 인터리빙 방식을 이용하여 트랜잭션들을 병행해서 수행시키는 것
- 직렬 가능 스케줄: 직렬 스케줄과 동일한 정확한 결과를 생성하는 비직렬 스케줄

<br/>

#### 11. 병행 제어 기법

병행 수행 하면서도 정확한 결과를 얻을 수 있는 직렬 가능성을 보장하는 것이다. 모든 트랜잭션들이 준수하면 직렬 가능성이 보장되는 규약을 정의하고 트랜잭션들이 이 규약을 따르도록 한다.

<br/>

#### 12. 로킹 기법

트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock 연산으로 제어한다. 로킹 단위가 커질수록 병행성이 낮아지지만 제어가 쉽고, 로킹 단위가 작아질수록 제어가 어렵지만 병행성이 높아진다

- lock 연산: 트랜잭션이 데이터에 대한 독점권을 요청하는 연산
- unlock 연산: 트랜잭션이 데이터에 대한 독점권을 반환하는 연산

<br/>

#### 13. 2단계 로킹 규약

트랜잭션이 lock과 unlock 연산을 확장 단계와 축소 단계로 나누어 수행해야 한다. 모든 트랜잭션이 2단계 로킹 규약을 준수하변 해당 스케줄은 직렬 가능성을 보장받는다.

- 확장 단계: 트랜잭션이 lock 연산만 실행할 수 있고, unlock 연산은 실행할 수 없는 단계
- 축소 단계: 트랜잭션이 unlock 연산만 실행할 수 있고, lock 연산은 실행할 수 없는 단계

=> 즉, 2단계 로킹 규약을 준수하는 트랜잭션은 첫 번째 unlock 연산을 실행하기 전에 필요한 모든 lock 연산을 실행해야 한다.
